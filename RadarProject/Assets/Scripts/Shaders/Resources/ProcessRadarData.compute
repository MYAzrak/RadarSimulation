#pragma kernel ProcessRadarData

// Define constants
#define THREAD_GROUP_SIZE 8

// Input textures and buffers
Texture2D<float4> InputTexture;
RWStructuredBuffer<int> RadarBuffer;
StructuredBuffer<float> RCSBuffer;

// Parameters
float MaxDistance;
float MinDistance;
float ParallelThreshold;
float Noise;
float Resolution;
int ImageRadius;
float CurrentRotation;

// Radar Equation Parameters
float TransmittedPower;
float AntennaGain;
float Wavelength;
float SystemLosses;

// Utility function to scale value
int ScaleValue(int originalValue, int originalMax, int newMax)
{
    return (int)round((float)originalValue / originalMax * newMax);
}

float CalculateSignalStrength(float distance, float radarCrossSection)
{
    float G = pow(10.0, AntennaGain / 10.0);
    float Ls = pow(10.0, SystemLosses / 10.0);
    float lambda = Wavelength;
    
    float Pr = (TransmittedPower * pow(G, 2) * pow(lambda, 2) * radarCrossSection) /
               (pow((4 * 3.14159), 3) * pow(distance, 4) * Ls);
    
    return 10 * log10(Pr);
}


[numthreads(THREAD_GROUP_SIZE, THREAD_GROUP_SIZE, 1)]
void ProcessRadarData(uint3 id : SV_DispatchThreadID)
{
    // Get the dimensions of the input texture
    uint width, height;
    InputTexture.GetDimensions(width, height);

    // Check if the current thread is within the texture bounds
    if (id.x < width && id.y < height)
    {
        // Sample the input texture
        float4 pixel = InputTexture[id.xy];
        
        // Extract normal and depth information
        float3 normal = pixel.rgb * 2 - 1; // Convert from [0,1] to [-1,1] range
        float viewSpaceDepth = pixel.a;
        
        // Clamp depth to valid range
        viewSpaceDepth = clamp(viewSpaceDepth, MinDistance, MaxDistance);

        // Calculate distance with noise
        int distance = (int)round(viewSpaceDepth);
        
        // Scale distance to image radius
        distance = ScaleValue(distance, (int)MaxDistance, ImageRadius);

        // Get the RCS value for this pixel
        float rcs = RCSBuffer[id.y * width + id.x] * normal[1];

        // Check if there's an object at this pixel (RCS > 0)
        if (distance > 10 && rcs > 0)
        {
            float signalStrength = CalculateSignalStrength(viewSpaceDepth, rcs);
            int scaledSignalStrength = (int)((signalStrength + 200) * 2); // Scale to 0-200 range assuming -100 to 0 dB
            InterlockedAdd(RadarBuffer[distance], scaledSignalStrength);

        }
    }
}
